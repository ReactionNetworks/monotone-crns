#!/usr/bin/env sage

##
# Search for monotone CRNs
#
# To do: write long description
#
# @author Pete Donnell <pete dot donnell at port dot ac dot uk>
# @copyright University of Portsmouth 2014
# @date 08/04/2014
##

# Custom libraries
import check_vec_monotone as cvm
import generate_vectors as gv

# Standard libraries
import ConfigParser
import itertools
import numpy
import sys
'''
N.B. ConfigParser was renamed to configparser in Python 3.x
Unfortunately, the version check below returns the version of Sage,
not the version of Python, so it can't be used. NumPy and Sage are
using Python 2.x for the foreseeable future, so it's not a big problem,
but this will need fixing eventually when they upgrade to Python 3.x.
Also, the syntax has changed, so the ini file code will need changing.
if sys.version_info[0] > 2
	import configparser
else
	import ConfigParser
'''

debug = False

# Specify some base parameters to constrain the search space
if len( sys.argv ) != 2:
	print( 'Usage: crn_search.sage <inifile>' )
	exit( 1 )
'''
Python 3.x version:
config = configparser.ConfigParser()
config.read( sys.argv[1] )
dimension = int( config['DEFAULT']['dimension'] )
dual_number_of_generators = int( config['DEFAULT']['dual_number_of_generators'] )
dual_min = int( config['DEFAULT']['dual_min'] )
dual_max = int( config['DEFAULT']['dual_max'] )
crn_max = int( config['DEFAULT']['crn_max'] )
'''
# Python 2.x version:
config = ConfigParser.ConfigParser()
config.read( sys.argv[1] )
dimension = config.getint( 'DEFAULT', 'dimension' )
dual_number_of_generators = config.getint( 'DEFAULT', 'dual_number_of_generators' )
dual_min = config.getint( 'DEFAULT', 'dual_min' )
dual_max = config.getint( 'DEFAULT', 'dual_max' )
crn_max = config.getint( 'DEFAULT', 'crn_max' )

# Output parameters for reference
print( 'Dimension = ' + str( dimension ) )
print( 'Dual number of generators = ' + str( dual_number_of_generators ) )
print( 'Dual generator minimum value = ' + str( dual_min ) )
print( 'Dual generator maximum value = ' + str( dual_max ) )
print( 'CRN vector maximum value = ' + str( crn_max ) )
print( '' )

# Calculate all possible sets of generators for the dual
dual_all_base_vectors = gv.generate_vectors( dimension, dual_max - dual_min, dual_min )
dual_base_vectors = [vector for vector in itertools.combinations(dual_all_base_vectors, dual_number_of_generators)]
if debug:
	print( 'Sets of possible dual vectors are ' )
	print( dual_base_vectors )
	print( '' )

# Calculate all possible CRN vectors, ignoring oppositely signed duplicates
crn_vectors = gv.generate_vectors( dimension, 2 * crn_max, -crn_max )
crn_vectors = crn_vectors[:len( crn_vectors ) / 2]
if debug:
	print( 'CRN vectors to test are ' )
	print( crn_vectors )
	print( '' )

##
# Check whether a given CRN vector lies in the span of a given cone
#
# @param   crn_vector  numpy.array  CRN vector
# @param   cone        sage.Cone    Cone
# @return  is_in_span  bool         True if CRN vector is in span of cone, False if not
##
def vector_in_cone_span( vector, cone ):
	# Check that the cone and the vector live in the same space
	if cone.lattice_dim() != len(vector):
		return False
	original_cone_dim = cone.dim()
	# Check whether the cone is solid
	if original_cone_dim == cone.lattice_dim():
		return True
	# Add the vector to the generators of the cone and check whether a higher-dimensional cone is produced
	else:
		rays = [ray for ray in cone.rays()]
		rays.append( vector.tolist() )
		new_cone = Cone( rays )
		if original_cone_dim < new_cone.dim():
			return False
		else:
			return True

# Go through each possible dual, and test each CRN in turn
number_of_interesting_cones = 0
for set_of_base_vectors in dual_base_vectors:
	preserved_crn_vectors = []
	dual_cone = Cone( [generator.tolist() for generator in set_of_base_vectors] )
	if debug:
		print( str( dual_cone.rays() ) )

	# Check that dual is solid, ensuring that the cone is pointed
	if dual_cone.dim() == dimension:
		cone = dual_cone.dual()
		cone_number_of_generators = len( cone.rays() )
		dual_cone_number_of_primitive_generators = len( dual_cone.rays() )
		for crn_vector in crn_vectors:
			if not cvm.not_red( crn_vector ):
				if debug:
					print( 'CRN vector ' + str( crn_vector ) + ' is not reduced.' )
				# process
				cone_matrix = cone.rays().column_matrix()
				dual_cone_matrix = dual_cone.rays().matrix()
				cone_rays = numpy.array( [numpy.array( column_vector ) for column_vector in cone_matrix ] )
				dual_cone_rays = numpy.array( [numpy.array( column_vector ) for column_vector in dual_cone_matrix ] )
				if not vector_in_cone_span( crn_vector, cone ):
					print( 'CRN vector ' + str( crn_vector ) + ' preserves cone generated by' )
					print( cone_matrix )
					print( 'but does not lie in its span' )
				if cvm.CRNv( cone_rays, dual_cone_rays, crn_vector, dimension, dual_cone_number_of_primitive_generators, cone_number_of_generators ):
					preserved_crn_vectors.append( crn_vector )
					if debug:
						print( 'CRN vector ' + str( crn_vector ) + ' is monotone w.r.t. cone generated by columns of' )
						print( str( cone.rays().column_matrix() ) )
	elif debug:
		print( 'Dual cone ' + str( dual_cone.rays() ) + ' is not solid. Ignoring.' )
	if len( preserved_crn_vectors ) > 1:
		number_of_interesting_cones += 1
		print( 'The cone generated by' )
		print( str( cone.rays().column_matrix() ) )
		print( 'is preserved by the following CRN vectors:' )
		for crn_vector in preserved_crn_vectors:
			sys.stdout.write( str( crn_vector ) )
			if numpy.count_nonzero( crn_vector ) > 2:
				print( '\t(non-interconversion reaction)' )
			else:
				print( '' )
		print( '' )
print( 'Found ' + str( number_of_interesting_cones ) + ' cones that preserve two or more reactions out of a total of ' + str( len( dual_base_vectors ) ) + ' possible cones.' )
print( '' )
